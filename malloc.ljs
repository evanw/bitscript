// K&R Malloc

struct Header {
  Header *next;
  uint size;
};

let Header *base = null;
let Header *freep = null;

function byte *malloc(int nbytes) {
  let Header *p, *prevp;
  let uint nunits = ((nbytes + sizeof(Header) - 1) / sizeof(Header)) + 1;

  if ((prevp = freep) === null) {
    base->next = freep = prevp = base;
    base->size = 0;
  }

  for (p = prevp->next;; prevp = p, p = p->next) {
    if (p->size >= nunits) {
      if (p->size === nunits) {
        prevp->next = p->next;
      } else {
        p->size -= nunits;
        p += p->size;
        p->size = nunits;
      }
      freep = prevp;
      return (byte *)(p + 1);
    }
    if (p === freep) {
      return null;
    }
  }
  return null;
}

function void free(byte *ap) {
  let Header *bp = (Header *)(ap) - 1, *p;
  for (p = freep; !(bp > p && bp < p->next); p = p->next) {
    if (p >= p->next && (bp > p || bp < p->next)) {
      break;
    }
  }
  if (bp + bp->size === p->next) {
    bp->size += p->next->size;
    bp->next = p->next->next;
  } else {
    bp->next = p->next;
  }
  if (p + p->size == bp) {
    p->size += bp->size;
    p->next = bp->next;
  } else {
    p->next = bp;
  }
  freep = p;
}
