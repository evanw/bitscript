// Inspired by: https://github.com/Constellation/escodegen
var cppcodegen;
(function (cppcodegen) {
    var indent;
    var base;
    var nullptr;
    var newlineBeforeBlock;

    (function (Syntax) {
        // Expressions
        Syntax.SequenceExpression = 'SequenceExpression';
        Syntax.AssignmentExpression = 'AssignmentExpression';
        Syntax.ConditionalExpression = 'ConditionalExpression';
        Syntax.BinaryExpression = 'BinaryExpression';
        Syntax.CallExpression = 'CallExpression';
        Syntax.NewExpression = 'NewExpression';
        Syntax.MemberExpression = 'MemberExpression';
        Syntax.UnaryExpression = 'UnaryExpression';
        Syntax.ThisExpression = 'ThisExpression';
        Syntax.Identifier = 'Identifier';
        Syntax.IntegerLiteral = 'IntegerLiteral';
        Syntax.DoubleLiteral = 'DoubleLiteral';
        Syntax.BooleanLiteral = 'BooleanLiteral';
        Syntax.StringLiteral = 'StringLiteral';
        Syntax.NullLiteral = 'NullLiteral';
        Syntax.SpecializeTemplate = 'SpecializeTemplate';

        // Statements
        Syntax.BlockStatement = 'BlockStatement';
        Syntax.BreakStatement = 'BreakStatement';
        Syntax.ContinueStatement = 'ContinueStatement';
        Syntax.DoWhileStatement = 'DoWhileStatement';
        Syntax.EmptyStatement = 'EmptyStatement';
        Syntax.ExpressionStatement = 'ExpressionStatement';
        Syntax.SwitchStatement = 'SwitchStatement';
        Syntax.SwitchCase = 'SwitchCase';
        Syntax.IfStatement = 'IfStatement';
        Syntax.Program = 'Program';
        Syntax.ReturnStatement = 'ReturnStatement';
        Syntax.WhileStatement = 'WhileStatement';
        Syntax.VariableDeclaration = 'VariableDeclaration';
        Syntax.FunctionDeclaration = 'FunctionDeclaration';
        Syntax.ObjectDeclaration = 'ObjectDeclaration';
        Syntax.ForStatement = 'ForStatement';
        Syntax.IncludeStatement = 'IncludeStatement';

        // Types
        Syntax.MemberType = 'MemberType';
        Syntax.ConstType = 'ConstType';
        Syntax.VolatileType = 'VolatileType';
        Syntax.PointerType = 'PointerType';
        Syntax.ReferenceType = 'ReferenceType';
        Syntax.FunctionType = 'FunctionType';
        Syntax.MemberPointerType = 'MemberPointerType';
        Syntax.ArrayType = 'ArrayType';
        Syntax.ObjectType = 'ObjectType';

        // Other
        Syntax.Variable = 'Variable';
    })(cppcodegen.Syntax || (cppcodegen.Syntax = {}));
    var Syntax = cppcodegen.Syntax;

    // See: http://en.cppreference.com/w/cpp/language/operator_precedence
    var Precedence;
    (function (Precedence) {
        Precedence[Precedence["Sequence"] = 0] = "Sequence";
        Precedence[Precedence["Throw"] = 1] = "Throw";
        Precedence[Precedence["Assignment"] = 2] = "Assignment";
        Precedence[Precedence["LogicalOR"] = 3] = "LogicalOR";
        Precedence[Precedence["LogicalAND"] = 4] = "LogicalAND";
        Precedence[Precedence["BitwiseOR"] = 5] = "BitwiseOR";
        Precedence[Precedence["BitwiseXOR"] = 6] = "BitwiseXOR";
        Precedence[Precedence["BitwiseAND"] = 7] = "BitwiseAND";
        Precedence[Precedence["Equality"] = 8] = "Equality";
        Precedence[Precedence["Relational"] = 9] = "Relational";
        Precedence[Precedence["BitwiseSHIFT"] = 10] = "BitwiseSHIFT";
        Precedence[Precedence["Additive"] = 11] = "Additive";
        Precedence[Precedence["Multiplicative"] = 12] = "Multiplicative";
        Precedence[Precedence["PointerToMember"] = 13] = "PointerToMember";
        Precedence[Precedence["Unary"] = 14] = "Unary";
        Precedence[Precedence["Postfix"] = 15] = "Postfix";
        Precedence[Precedence["Scope"] = 16] = "Scope";
    })(Precedence || (Precedence = {}));

    var BinaryPrecedence = {
        '||': Precedence.LogicalOR,
        '&&': Precedence.LogicalAND,
        '|': Precedence.BitwiseOR,
        '^': Precedence.BitwiseXOR,
        '&': Precedence.BitwiseAND,
        '==': Precedence.Equality,
        '!=': Precedence.Equality,
        '<': Precedence.Relational,
        '>': Precedence.Relational,
        '<=': Precedence.Relational,
        '>=': Precedence.Relational,
        '<<': Precedence.BitwiseSHIFT,
        '>>': Precedence.BitwiseSHIFT,
        '+': Precedence.Additive,
        '-': Precedence.Additive,
        '*': Precedence.Multiplicative,
        '%': Precedence.Multiplicative,
        '/': Precedence.Multiplicative,
        '[]': Precedence.Postfix,
        '.*': Precedence.PointerToMember,
        '->*': Precedence.PointerToMember
    };

    var AssignmentOperators = {
        '=': true,
        '+=': true,
        'âˆ’=': true,
        '*=': true,
        '/=': true,
        '%=': true,
        '<<=': true,
        '>>=': true,
        '&=': true,
        '^=': true,
        '|=': true
    };

    var BinaryOperators = {
        '||': true,
        '&&': true,
        '|': true,
        '^': true,
        '&': true,
        '==': true,
        '!=': true,
        '<': true,
        '>': true,
        '<=': true,
        '>=': true,
        '<<': true,
        '>>': true,
        '+': true,
        '-': true,
        '*': true,
        '%': true,
        '/': true,
        '[]': true,
        '.*': true,
        '->*': true
    };

    var MemberOperators = {
        '.': true,
        '->': true,
        '::': true
    };

    var UnaryOperators = {
        '+': true,
        '-': true,
        '~': true,
        '!': true,
        '*': true,
        '&': true,
        '++': true,
        '--': true,
        'sizeof': true,
        'delete': true,
        'delete []': true
    };

    var ObjectTypeKeywords = {
        'struct': true,
        'union': true,
        'class': true
    };

    function stringRepeat(str, num) {
        var result = '';
        for (num |= 0; num > 0; num >>>= 1, str += str) {
            if (num & 1) {
                result += str;
            }
        }
        return result;
    }

    function parenthesize(text, current, should) {
        return current < should ? '(' + text + ')' : text;
    }

    function isIdentifierPart(ch) {
        return ch >= 'a' && ch <= 'z' || ch >= 'A' && ch <= 'Z' || ch >= '0' && ch <= '9' || ch === '_';
    }

    function increaseIndent() {
        base += indent;
    }

    function decreaseIndent() {
        base = base.slice(0, base.length - indent.length);
    }

    function join(left, right) {
        var leftChar = left.charAt(left.length - 1);
        var rightChar = right.charAt(0);
        if ((leftChar === '+' || leftChar === '-' || leftChar === '<' || leftChar === '>') && leftChar === rightChar || isIdentifierPart(leftChar) && isIdentifierPart(rightChar)) {
            return left + ' ' + right;
        }
        return left + right;
    }

    function generateNumber(value) {
        if (typeof value !== 'number') {
            throw new Error('Numeric literal with non-numeric value: ' + value);
        }
        if (value !== value) {
            throw new Error('Numeric literal whose value is NaN');
        }
        if (value < 0 || value === 0 && 1 / value < 0) {
            throw new Error('Numeric literal whose value is negative');
        }
        return value + '';
    }

    function generateIdentifier(node) {
        if (node.kind !== Syntax.Identifier) {
            throw new Error('Expected identifier but got kind: ' + node.kind);
        }
        return node.name;
    }

    function generateQualifierList(node) {
        return 'qualifiers' in node ? node.qualifiers.map(function (n) {
            return generateIdentifier(n) + ' ';
        }).join('') : '';
    }

    function generateExpression(node, precedence) {
        var result;

        switch (node.kind) {
            case Syntax.SequenceExpression:
                result = node.expressions.map(function (n) {
                    return generateExpression(n, Precedence.Assignment);
                }).join(', ');
                result = parenthesize(result, Precedence.Sequence, precedence);
                break;

            case Syntax.AssignmentExpression:
                if (!(node.operator in AssignmentOperators)) {
                    throw new Error('Assigment expression with invalid operator: ' + node.operator);
                }
                result = generateExpression(node.left, Precedence.Postfix) + ' ' + node.operator + ' ' + generateExpression(node.right, Precedence.Assignment);
                result = parenthesize(result, Precedence.Assignment, precedence);
                break;

            case Syntax.ConditionalExpression:
                result = generateExpression(node.test, Precedence.LogicalOR) + ' ? ' + generateExpression(node.consequent, Precedence.Assignment) + ' : ' + generateExpression(node.alternate, Precedence.Assignment);
                result = parenthesize(result, Precedence.Assignment, precedence);
                break;

            case Syntax.BinaryExpression:
                if (!(node.operator in BinaryOperators)) {
                    throw new Error('Binary expression with invalid operator: ' + node.operator);
                }
                var currentPrecedence = BinaryPrecedence[node.operator];
                result = generateExpression(node.left, currentPrecedence);
                if (node.operator === '[]') {
                    result += '[' + generateExpression(node.right, Precedence.Sequence) + ']';
                } else {
                    var space = node.operator === '.*' || node.operator === '->*' ? '' : ' ';
                    result += space + node.operator + space + generateExpression(node.right, currentPrecedence + 1);
                }
                result = parenthesize(result, currentPrecedence, precedence);
                break;

            case Syntax.CallExpression:
                result = generateExpression(node.callee, Precedence.Postfix) + '(' + node['arguments'].map(function (n) {
                    return generateExpression(n, Precedence.Assignment);
                }).join(', ') + ')';
                result = parenthesize(result, Precedence.Postfix, precedence);
                break;

            case Syntax.NewExpression:
                result = 'new ' + generateExpression(node.callee, Precedence.Postfix) + '(' + node['arguments'].map(function (n) {
                    return generateExpression(n, Precedence.Assignment);
                }).join(', ') + ')';
                result = parenthesize(result, Precedence.Unary, precedence);
                break;

            case Syntax.MemberExpression:
                if (!(node.operator in MemberOperators)) {
                    throw new Error('Member expression with invalid operator: ' + node.operator);
                }
                result = generateExpression(node.object, Precedence.Postfix) + node.operator + generateIdentifier(node.member);
                result = parenthesize(result, Precedence.Postfix, precedence);
                break;

            case Syntax.UnaryExpression:
                if (!(node.operator in UnaryOperators)) {
                    throw new Error('Unary expression with invalid operator: ' + node.operator);
                }
                var prefix = 'prefix' in node ? node.prefix : true;
                if (typeof prefix !== 'boolean' || !prefix && node.operator !== '++' && node.operator !== '--') {
                    throw new Error('Unary expression with incorrect prefix flag: ' + prefix);
                }
                if (prefix) {
                    result = join(node.operator, generateExpression(node.argument, Precedence.Unary));
                    result = parenthesize(result, Precedence.Unary, precedence);
                } else {
                    result = join(generateExpression(node.argument, Precedence.Postfix), node.operator);
                    result = parenthesize(result, Precedence.Postfix, precedence);
                }
                break;

            case Syntax.ThisExpression:
                result = 'this';
                break;

            case Syntax.Identifier:
                result = node.name;
                break;

            case Syntax.IntegerLiteral:
                result = generateNumber(node.value);
                break;

            case Syntax.DoubleLiteral:
                result = generateNumber(node.value);
                if (!/\./.test(result))
                    result = result.replace(/(e|$)/, '.0$1');
                break;

            case Syntax.BooleanLiteral:
                if (typeof node.value !== 'boolean') {
                    throw new Error('Boolean literal with non-boolean value: ' + node.value);
                }
                result = node.value + '';
                break;

            case Syntax.StringLiteral:
                if (typeof node.value !== 'string') {
                    throw new Error('String literal with non-string value: ' + node.value);
                }
                result = JSON.stringify(node.value);
                break;

            case Syntax.NullLiteral:
                result = nullptr ? 'nullptr' : 'NULL';
                break;

            case Syntax.SpecializeTemplate:
                result = generateExpression(node.template, Precedence.Scope) + '<' + join(node.parameters.map(function (n) {
                    return generateExpression(n, Precedence.Sequence);
                }).join(', '), '>');
                break;

            default:
                return wrapIdentifierWithType(node, null, new WrapContext());
        }

        return result;
    }

    function beforeBlock() {
        return newlineBeforeBlock ? '\n' + base : ' ';
    }

    function generatePossibleBlock(node) {
        return (node.kind === Syntax.BlockStatement ? beforeBlock() : ' ') + generateStatement(node);
    }

    function generateStatement(node) {
        var result;

        switch (node.kind) {
            case Syntax.BlockStatement:
                result = '{\n';
                increaseIndent();
                result += node.body.map(function (n) {
                    return base + generateStatement(n) + '\n';
                }).join('');
                decreaseIndent();
                result += base + '}';
                break;

            case Syntax.BreakStatement:
                result = 'break;';
                break;

            case Syntax.ContinueStatement:
                result = 'continue;';
                break;

            case Syntax.DoWhileStatement:
                result = 'do' + generatePossibleBlock(node.body) + ' while (' + generateExpression(node.test, Precedence.Sequence) + ')';
                break;

            case Syntax.EmptyStatement:
                result = ';';
                break;

            case Syntax.ExpressionStatement:
                result = generateExpression(node.expression, Precedence.Sequence) + ';';
                break;

            case Syntax.SwitchStatement:
                result = 'switch (' + generateExpression(node.discriminant, Precedence.Sequence) + ')' + beforeBlock() + '{\n';
                result += node.cases.map(function (n) {
                    return base + generateStatement(n) + '\n';
                });
                result += base + '}';
                break;

            case Syntax.SwitchCase:
                if ('test' in node && node.test !== null) {
                    result = 'case ' + generateExpression(node.test, Precedence.Sequence) + ':\n';
                } else {
                    result = 'default:\n';
                }
                increaseIndent();
                result += node.consequent.map(function (n) {
                    return base + generateStatement(n) + '\n';
                });
                decreaseIndent();
                break;

            case Syntax.IfStatement:
                result = 'if (' + generateExpression(node.test, Precedence.Sequence) + ')' + generatePossibleBlock(node.consequent) + (!('alternate' in node) || node.alternate === null ? '' : ' else' + generatePossibleBlock(node.alternate));
                break;

            case Syntax.ReturnStatement:
                result = 'return' + ('argument' in node && node.argument !== null ? ' ' + generateExpression(node.argument, Precedence.Sequence) : '') + ';';
                break;

            case Syntax.WhileStatement:
                result = 'while (' + generateExpression(node.test, Precedence.Sequence) + ')' + generatePossibleBlock(node.body);
                break;

            case Syntax.ForStatement:
                result = 'for (';
                result += 'init' in node ? node.init.kind === Syntax.VariableDeclaration ? generateStatement(node.init) : generateExpression(node.init, Precedence.Sequence) + ';' : ';';
                result += 'test' in node && node.test !== null ? ' ' + generateExpression(node.test, Precedence.Sequence) + ';' : ';';
                result += ('update' in node && node.update !== null ? ' ' + generateExpression(node.update, Precedence.Sequence) : '') + ')';
                result += generatePossibleBlock(node.body);
                break;

            case Syntax.IncludeStatement:
                result = '#include ' + node.text;
                break;

            case Syntax.VariableDeclaration:
                var prefix = null;
                result = (generateQualifierList(node) + node.variables.map(function (n, i) {
                    var context = new WrapContext();
                    context.includePrefix = i === 0;
                    var result = generateVariable(n, context);
                    if (prefix !== null && prefix !== context.prefix) {
                        throw new Error('Type prefix ' + prefix + ' does not match type prefix ' + context.prefix);
                    }
                    prefix = context.prefix;
                    return result;
                }).join(', ')).trim() + ';';
                break;

            case Syntax.FunctionDeclaration:
                result = generateQualifierList(node) + wrapIdentifierWithType(node.type, node.id, new WrapContext()) + ('initializations' in node && node.initializations !== null && node.initializations.length > 0 ? ' : ' + node.initializations.map(function (n) {
                    return generateExpression(n, Precedence.Sequence);
                }).join(', ') : '') + ('body' in node && node.body !== null ? node.body.kind === 'BlockStatement' ? generatePossibleBlock(node.body) : ' = ' + generateExpression(node.body, Precedence.Sequence) + ';' : ';');
                break;

            case Syntax.ObjectDeclaration:
                result = wrapIdentifierWithType(node.type, null, new WrapContext()) + ';';
                break;

            default:
                throw new Error('Unknown statement kind: ' + node.kind);
        }

        return result;
    }

    var WrapContext = (function () {
        function WrapContext() {
            this.prefix = '';
            this.before = '';
            this.after = '';
            this.isWrapping = false;
            this.includePrefix = true;
        }
        WrapContext.prototype.join = function (name, includePrefix) {
            return ((includePrefix ? this.prefix + ' ' : '') + (name !== null ? this.before + name : this.before.trim()) + this.after).trim();
        };
        return WrapContext;
    })();

    function wrapInnerType(node) {
        var context = new WrapContext();
        wrapType(node, context);
        return context.isWrapping ? '(' + context.join(null, true) + ')' : context.prefix;
    }

    function wrapType(node, context) {
        switch (node.kind) {
            case Syntax.Identifier:
            case Syntax.SpecializeTemplate:
                context.prefix = generateExpression(node, Precedence.Scope);
                break;

            case Syntax.MemberType:
                context.prefix = ('inner' in node && node.inner !== null ? wrapInnerType(node.inner) : '') + '::' + generateIdentifier(node.member);
                break;

            case Syntax.ObjectType:
                if (!(node.keyword in ObjectTypeKeywords)) {
                    throw new Error('Unknown object type keyword: ' + node.keyword);
                }
                context.prefix = node.keyword + ('id' in node && node.id !== null ? ' ' + generateIdentifier(node.id) : '') + ('bases' in node && node.bases !== null && node.bases.length > 0 ? ' : ' + node.bases.map(function (n) {
                    return generateExpression(n, Precedence.Sequence);
                }) : '') + ('body' in node && node.body !== null ? generatePossibleBlock(node.body) : '');
                break;

            case Syntax.ConstType:
            case Syntax.VolatileType:
                wrapType(node.inner, context);
                var keyword = node.kind === Syntax.ConstType ? 'const ' : 'volatile ';
                if (context.isWrapping)
                    context.before = context.before + keyword;
else
                    context.prefix = keyword + context.prefix;
                break;

            case Syntax.PointerType:
            case Syntax.ReferenceType:
            case Syntax.MemberPointerType:
                wrapType(node.inner, context);
                context.isWrapping = true;
                if (node.inner.kind === Syntax.ArrayType || node.inner.kind === Syntax.FunctionType) {
                    context.before += '(';
                    context.after = ')' + context.after;
                }
                context.before += node.kind === Syntax.PointerType ? '*' : node.kind === Syntax.ReferenceType ? '&' : wrapInnerType(node.object) + '::*';
                break;

            case Syntax.ArrayType:
                wrapType(node.inner, context);
                context.isWrapping = true;
                context.after = '[' + (node.size !== null ? generateExpression(node.size, Precedence.Sequence) : '') + ']' + context.after;
                break;

            case Syntax.FunctionType:
                if ('return' in node && node['return'] !== null)
                    wrapType(node['return'], context);
                context.isWrapping = true;
                context.after = '(' + node['arguments'].map(function (n) {
                    return generateVariable(n, new WrapContext());
                }).join(', ') + ')' + context.after;
                break;

            default:
                throw new Error('Unknown type node kind: ' + node.kind);
        }
    }

    function wrapIdentifierWithType(type, id, context) {
        wrapType(type, context);
        var name = id === null ? null : wrapInnerType(id);
        return context.join(name, context.includePrefix);
    }

    function generateVariable(node, context) {
        if (node.kind !== Syntax.Variable) {
            throw new Error('Expected variable but got kind: ' + node.kind);
        }
        if (node.id === null && node.init !== null) {
            throw new Error('Cannot initialize anonymous variable');
        }
        return wrapIdentifierWithType(node.type, 'id' in node ? node.id : null, context) + ('init' in node && node.init !== null ? ' = ' + generateExpression(node.init, Precedence.Assignment) : '');
    }

    function generate(node, options) {
        var result;

        options = options || {};
        indent = options.indent || '    ';
        base = options.base || '';
        nullptr = !!options.nullptr;
        newlineBeforeBlock = !!options.newlineBeforeBlock;

        switch (node.kind) {
            case Syntax.Program:
                result = node.body.map(function (n) {
                    return base + generateStatement(n) + '\n';
                }).join('');
                break;

            case Syntax.BlockStatement:
            case Syntax.BreakStatement:
            case Syntax.ContinueStatement:
            case Syntax.DoWhileStatement:
            case Syntax.EmptyStatement:
            case Syntax.ExpressionStatement:
            case Syntax.SwitchStatement:
            case Syntax.SwitchCase:
            case Syntax.IfStatement:
            case Syntax.ReturnStatement:
            case Syntax.WhileStatement:
            case Syntax.VariableDeclaration:
            case Syntax.FunctionDeclaration:
            case Syntax.ObjectDeclaration:
            case Syntax.ForStatement:
            case Syntax.IncludeStatement:
                result = generateStatement(node);
                break;

            case Syntax.SequenceExpression:
            case Syntax.AssignmentExpression:
            case Syntax.ConditionalExpression:
            case Syntax.BinaryExpression:
            case Syntax.CallExpression:
            case Syntax.NewExpression:
            case Syntax.MemberExpression:
            case Syntax.UnaryExpression:
            case Syntax.ThisExpression:
            case Syntax.Identifier:
            case Syntax.IntegerLiteral:
            case Syntax.DoubleLiteral:
            case Syntax.BooleanLiteral:
            case Syntax.StringLiteral:
            case Syntax.NullLiteral:
            case Syntax.SpecializeTemplate:
                result = generateExpression(node, Precedence.Sequence);
                break;

            case Syntax.MemberType:
            case Syntax.ConstType:
            case Syntax.VolatileType:
            case Syntax.PointerType:
            case Syntax.ReferenceType:
            case Syntax.FunctionType:
            case Syntax.MemberPointerType:
            case Syntax.ArrayType:
            case Syntax.ObjectType:
                result = wrapIdentifierWithType(node, null, new WrapContext());
                break;

            case Syntax.Variable:
                result = generateVariable(node, new WrapContext());
                break;

            default:
                throw new Error('Unknown node kind: ' + node.kind);
        }

        return result;
    }
    cppcodegen.generate = generate;
})(cppcodegen || (cppcodegen = {}));

if (typeof exports !== 'undefined') {
    exports = cppcodegen;
}
//# sourceMappingURL=cppcodegen.js.map
